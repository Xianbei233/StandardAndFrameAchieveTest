# 前端面试押题

## 网络
1. tcp（三次握手，四次断手）
2. http（cookie，cache，session）
    
    cache：响应头通过Cache-control首部控制缓存规则
    ```
    cache-control:
    请求Request：

        [1] no-cache  ---- 不要读取缓存中的文件，要求向WEB服务器重新请求

        [2] no-store    ---- 请求和响应都禁止被缓存
        [2] max-age： ---- 表示当访问此网页后的max-age秒内再次访问不会去服务器请求，其功能与Expires类似，只是Expires是根据某个特定日期值做比较。一但缓存者自身的时间不准确.则结果可能就是错误的，而max-age,显然无此问题.。Max-age的优先级也是高于Expires的。
        [3] max-stale  ---- 允许读取过期时间必须小于max-stale 值的缓存对象。 
        [4] min-fresh ---- 接受其max-age生命期大于其当前时间 跟 min-fresh 值之和的缓存对象

        [5] only-if-cached ---- 告知缓存者,我希望内容来自缓存，我并不关心被缓存响应,是否是新鲜的.

        [6] no-transform   ---- 告知代理,不要更改媒体类型,比如jpg,被你改成png.



    响应Response：

        [1] public    ---- 数据内容皆被储存起来，就连有密码保护的网页也储存，安全性很低
        [2] private    ---- 数据内容只能被储存到私有的cache，仅对某个用户有效，不能共享
        [3] no-cache    ---- 可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端

        [4] no-store  ---- 请求和响应都禁止被缓存

        [4] max-age：   ----- 本响应包含的对象的过期时间
        [5] Must-revalidate    ---- 如果缓存过期了，会再次和原来的服务器确定是否为最新数据，而不是和中间的proxy

        [6] max-stale  ----  允许读取过期时间必须小于max-stale 值的缓存对象。 

        [7] proxy-revalidate  ---- 与Must-revalidate类似，区别在于：proxy-revalidate要排除掉用户代理的缓存的。即其规则并不应用于用户代理的本地缓存上。

        [8] s-maxage  ---- 与max-age的唯一区别是,s-maxage仅仅应用于共享缓存.而不应用于用户代理的本地缓存等针对单用户的缓存. 另外,s-maxage的优先级要高于max-age.

        [9] no-transform   ---- 告知代理,不要更改媒体类型,比如jpg,被你改成png.
    ```

    Last-Modified / If-Modified-Since

        Last-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间。

        If-Modified-Since:再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。

    Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）

        Etag:文件标签，状态唯一，文件发生更改则变化

        



3. https（链接建立，公私钥生成）

    ![https](https://klionsec.github.io/img/https1.png)

```
-> 客户端向服务端发送请求 
   -> 服务端返回数字证书 
	-> 客户端用自己的CA[主流的CA机构证书一般都内置在各个主流浏览器中]公钥去解密证书,如果证书有问题会提示风险 
	    -> 如果证书没问题客户端会生成一个对称加密的随机秘钥然后再和刚刚解密的服务器端的公钥对数据进行加密,然后发送给服务器端 
		  -> 服务器端收到以后会用自己的私钥对客户端发来的对称秘钥进行解密 
			-> 之后双方就拿着这个对称加密秘钥来进行正常的通信
```

4. 状态码（什么情况下会返回怎样的状态码）
    1系：信息响应

    2系：请求成功
    ```
        200 成功(ok)：标准的HTTP请求响应成功状态码，get请求中，响应将包含与请求对应的实体，post请求中，响应将包含实体的描述或实体的操作结果。
        202 已接受请求(Accepted)：服务端接受了请求，但还没处理，最终可能会成功、或不会被执行或禁止执行
        204 无内容(No Content)：服务端成功处理了请求，但没返回任何内容
        205 重置内容(Reset Content)：服务端成功处理了请求，但没返回任何内容，区别于204的是：该响应要求客户端重置文档视图。
        206 部分内容(Partial Content)：服务端成功处理了请求的部分内容，该状态码一般用于HTTP下载工具的断点续传功能或多个下载的分段进行(如迅雷下载)
    ```

    3系：重定向
    ```
        301 永久移动(Moved Permanently)：被请求资源已被永久的转移到新位置，并且将来对此资源的引用都应该使用它返回的URI之一，新的永久性URI将在Location域中返回。永远也别来烦我，去找张三吧。
        302 临时移动(Found，原始短语为Moved Temporarily)：由于移动式临时的，客户端以后还是用原来的地址发送请求，新的临时URI将在Location域中返回
        303 看其它(See Other)：请求的地址已经被移动，请求的对应地址可以在另一个URI上被找到
        304 未修改(Not Modified)：表示当前资源的版本在根据请求头的If-Modified-Since和If-None-Match参数判断缓存后，资源未曾被修改，这样客户端不需要重新传新资源，客户端仍然使用上次下载的资源复件。
    ```

    4系：客户端错误
    ```
        400 错误请求(Bad Request)：明显的客户端错误请求(如：语法缺陷，请求包过大、无效的请求消息片段、欺诈性请求路由)
        401 未授权(Unauthorized)：类似于403 Forbidden错误，但不同的是该错误是指在特定的认证情况下，用户未能通过认证(如：登陆认证)
        403 已拒绝(Forbidden)：该请求已被服务器验证为有效，但是服务器拒绝了它的操作，一般是因为用户没有取得对应资源的使用权。
        404 未找到(Not Found)
        405 方法不被允许(Method Not Allowed)：该请求方法不支持对需请求资源的访问。如：明明是需要post方法的，你却给我传了个get方法
        406 请求无法接受(Not Acceptable)：请求资源的内容格式无法满足请求头中的要求，因而无法生成响应体，故无法接受，请求的格式由Content-type头重定义的媒体类型决定
        408 请求超时(Request Timeout)：客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。
        409 冲突(Confict)：因为请求存在冲突无法处理，比如多人在线编辑工具出现的冲突
    ```

    5系：服务器错误
    ```
        500 内部服务错误(Internal Server Error)：通用错误消息，服务端遇到了一个未曾预料的情况(如：服务端可能没有使用try catch等错误处理机制来抓到并处理错误异常)，无法给出更具体的错误消息来解释 —— 我的错，但我不知道我错哪了
        501 请求无法实现(Not implemented)：服务端不支持当前请求中所需的某个功能—— 臣妾做不到啊！
        502 损坏的网关(Bad Gateway)：作为网关或代理工作的服务端尝试执行请求时，从上游服务器接收到无效的响应。
        503 服务不可用(Service Unavailable)：由于临时的请求过载，导致服务端无法处理请求，该状况只是暂时的，并且会在一段时间后恢复，如果能预计延迟时间，那么响应中包含一个Retry-After头来标明延迟时间。
    ```

## HTML5
1. 语义化（优点）
2. DOM（遍历优化,结构调整）
3. 安全措施


## css3
1. 伪类选择器
2. 权重
3. 动画实现
4. 布局实现

## ES5
1. 闭包
2. 原型链（继承）
    
    原型链继承（this指向未更改）
    构造继承（原型链未继承）
    组合继承（臃肿，性能差）
    原型继承（

3. 正则表达式、replace操作

## ES6
1. symbol

    唯一标识符 `let a = Symbol('asd')`
    
    参数是标识说明（描述）
    
    值是独一无二的

    一般作为标识符用于对象的key name，可防止key被改写或覆盖

    Symbol属性名赋值只能用`object[SymbolKey]`的方法赋值，不能`object.SymbolKey`的方式赋值，因为点运算符后跟的始终是一个字符串，而symbol不是字符串

    Symbol属性名无法遍历枚举，只能通过特定方法判断是否存在，此特性可用于声明非私有但不想被枚举只能内部使用的属性方法

    注意：`

2. promise
3. generator
4. async、await

## 框架
1. 脏值检测
2. 数据劫持
3. 双向绑定
4. 模板编译
5. computed实现
6. 发布订阅模式
7. DOM-Diff算法

## 开发
1. 开发模式选择

## 需要继续准备的题目

1. 简单自我介绍
 
2. 介绍项目
 
3. 登录验证怎么做的（没有说token）
 
4. 路由组件怎么缓存
 
5. 用没有用过keep-alive
 
6. computed和data区别
 
7. cookie和session区别
 
8. 怎么禁止前端使用cookie
 
9. 有几种跨域的方式，分别

10. 怎么实时刷新列表
 
11. 除了settimeout还有什么
 
12. 有用过websocket吗
 
13. http的长轮询
 
14. 服务器端的推送？
 
15. 事件绑定，考虑到性能页面优化的情况下，怎么绑定比较好
 
16. 事件委托是什么
 
17. 父组件怎么判断触发在哪个子组件上
 
18. csrf攻击原理及怎么防范
 
19. 怎么用token防范，token存在哪里
 
20. tcp如果没有第三次握手会怎么样
 
21. 强制缓存和协商缓存，304是哪个缓存
 
22. 用过哪些es6语法，追问promise
 
23. promise和setTimeout有什么区别
 
24. 宏任务和微任务有了解过吗，promise属于哪个
 
25. 有用过css的预处理语法吗
 
26. 用过webpack吗
 
27. webpack怎么把css文件单独分离出来
 
28. 热更新怎么实现的
 
29. 代码混淆怎么实现
 
30. webpack怎么写
 
31. 如果一个页面有多个入口，怎么配
 
32. 第三方库怎么做
 
33. 怎么把第三方库单独分离出来

34.学前端多久了，平时怎么学的？读过什么相关的书籍吗